# C++核心编程

本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓。

- **[1.内存分区模型](./01_内存分区模型)**

    C++程序在执行时，将内存大方向划分为**4个区域**

    - 代码区：存放函数体的二进制代码，由操作系统进行管理的
    - 全局区：存放全局变量和静态变量以及常量
    - 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
    - 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收



- **[02.引用](./02_引用)**

    **作用： **给变量起别名

    **语法：** `数据类型 &别名 = 原名`

    

- **[03.函数提高](./03_函数提高)**

    - 3.1 函数默认参数

    - 3.2 函数占位参数

    - 3.3 函数重载

    

- **[04.类与对象](./04_类与对象)**

    - **[4.1_封装](./04_类与对象/4.1_封装)**

        - 4.1.1 封装的意义

            封装是C++面向对象三大特性之一

            封装的意义：

            ​    a. 将属性和行为作为一个整体，表现生活中的事物

            ​    b. 将属性和行为加以权限控制

            

        - 4.1.2 struct和class区别

        - 4.1.3 成员属性设置为私有

        

        

    - **[4.2_对象的初始化和清理](./04_类与对象/4.2_对象的初始化和清理)**

        - 4.2.1 构造函数和析构函数

            c++利用了**构造函数**和**析构函数**解决对象的**初始化和清理**，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

            **构造函数**：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。

            **析构函数**：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

            

        - 4.2.2 构造函数的分类及调用

        - 4.2.3 拷贝构造函数调用时机

        - 4.2.4 构造函数调用规则

        - 4.2.5 深拷贝与浅拷贝

        - 4.2.6 初始化列表

        - 4.2.7 类对象作为类成员

        - 4.2.8 静态成员

        

        

        

    - **[4.3_对象模型和this指针](./04_类与对象/4.3_对象模型和this指针)**

        - 4.3.1 成员变量和成员函数分开存储

            在C++中，类内的成员变量和成员函数分开存储.

            只有**非静态成员变量**才属于类的对象上.

            

        - 4.3.2 this指针概念

            **this指针指向被调用的成员函数所属的对象**

            

        - 4.3.3 空指针访问成员函数

        - 4.3.4 const修饰成员函数

        

    - **[4.4_友元](./04_类与对象/4.4_友元)**

        友元的目的就是让一个函数或者类 访问另一个类中私有成员

        友元的关键字为`friend`

        

        - 4.4.1 全局函数做友元

        - 4.4.2 类做友元

        - 4.4.3 成员函数做友元

        

    - **[4.5_运算符重载](./04_类与对象/4.5_运算符重载)**

        运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型.

        

        - 4.5.1 加号运算符重载

        - 4.5.2 左移运算符重载

        - 4.5.3 递增运算符重载

        - 4.5.4 赋值运算符重载

        - 4.5.5 关系运算符重载

        - 4.5.6 函数调用运算符重载

        

    - **[4.6_继承](./04_类与对象/4.6_继承)**

        

        - 4.6.1 继承的基本语法

            继承的语法：`class 子类 : 继承方式  父类`

            

        - 4.6.2 继承方式

            **继承方式一共有三种：**公共继承, 保护继承, 私有继承

            

        - 4.6.3 继承中的对象模型

        - 4.6.4 继承中构造和析构顺序

            继承中先调用父类构造函数，再调用子类构造数，析构顺序与构造相反

            

        - 4.6.5 继承同名成员处理方式

            a. 访问子类同名成员,  直接访问即可

            b. 访问父类同名成员,  需要加作用域

            

        - 4.6.6 继承同名静态成员处理方式

        - 4.6.7 多继承语法

        - 6.8 菱形继承

        

    - **[4.7_多态](./04_类与对象/4.7_多态)**

        **多态是C++面向对象三大特性之一**

        

        - 4.7.1 多态的基本概念

            多态分为两类

            a. 静态多态: 函数重载和运算符重载属于静态多态，复用函数名。静态多态的函数地址早绑定  -  编译阶段确定函数地址

            b. 动态多态: 派生类和虚函数实现运行时多态。动态多态的函数地址晚绑定  -  运行阶段确定函数地址

            

            函数前面加上`virtual`关键字，变成**虚函数**，那么编译器在编译的时候就不能确定函数调用了。

            **多态满足条件**： 
                a. 有继承关系
                b. 子类重写父类中的虚函数
            **多态使用：父类指针或引用指向子类对象**

            

        - 4.7.2 多态案例一-计算器类

        - 4.7.3 纯虚函数和抽象类

            在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容。因此可以将虚函数改为**纯虚函数**。

            

            纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`

            

            当类中有了纯虚函数，这个类也称为抽象类。

            

            **抽象类特点**：

             * 无法实例化对象

             * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

                

        - 4.7.4 多态案例二-制作饮品

        - 4.7.5 虚析构和纯虚析构

            多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。

            解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**。

            虚析构语法：

            `virtual ~类名(){}`

            纯虚析构语法：

            ` virtual ~类名() = 0;`

            `类名::~类名(){}`

            

        - 4.7.6 多态案例三-电脑组装

        

- [05.文件操作](./05_文件操作)





---

## 参考资料

1. [黑马程序员匠心之作|C++教程从0到1入门编程](https://www.bilibili.com/video/av41559729/)
2. [Github资料：C++ 匠心之作 从0到1入门资料](https://github.com/AnkerLeng/Cpp-0-1-Resource)